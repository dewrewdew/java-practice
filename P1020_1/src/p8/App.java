package p8;

public class App {
    public static void main(String[] args) {
        // 다형성
        AAA a1 = new AAA();
        // = 기준 왼쪽은 변수 생성, 오른쪽은 인스턴스 생성
        BBB b1 = new BBB();
        AAA b2 = new BBB(); 
        // 다형성 => 자식 포함 자손까지의 모든 변수 생성 가능!
        // 자식 인스턴스를 부모 클래스에 넣는건 가능! 반대는 불가능 => 조치가 필요함
        // b2.a1 = 10;
        // b2.으로 확인해보면 쓸 수 있는게 a1, a2밖에 없음!
        // 이제부터는 문법과 런타임이 틀어질 것!!
        // AAA b2 = new BBB(); => 문법(컴파일 오류)은 = 왼쪽 즉, 변수 선언부를 따르고, 런타임은 =의 오른쪽 즉 인스턴스 생성부를 따른다.
        // 깊게 이해하려들지 말 것!! 헷갈림!! 그리고 깊게 이해해야할 부분이 아님!!
        // 지금은 그냥 class BBB의 메서드를 쓰고싶으면 인스턴스를 BBB 변수에 담자고 생각하고 끝내기!(b2.testB()); 실행 불가
        // 지금 이것만 가지고는 자식들의 특성들을 사용을 못함!
        BBB tempB = (BBB)b2;
        // 부모 클래스 내용을 자식클래스에 바로 적용은 x 캐스팅해야함!! (단, 이것도 상속관계일 경우에만 가능)
        // 캐스팅은 위험하니 확신이 있는경우에만 사용! => 어떻게 확신하는가? instanceof 사용!!

        // if(b2 instanceof BBB) {
        // BBB tempB = (BBB)b2;
        // tempB.testB;
        // }



        tempB.testB();
        // 위 코드는 문법상으로는 문제가 x => 런타임 오류 뜸!! 이제부터는 문법과 런타임 시 오류가 별개로 발생함 잘 구분할 것!
    }
}

class AAA {
    int a1;
    int a2;
}

class BBB extends AAA{
    int b1;
    int b2;

    void testB() {

    }
}
// "상속 관계로 되어있는 경우에 한해" AAA b2 = new BBB(); => 가능
// 특정 타입(AAA)의 변수는 특정 타입(AAA)를 상속받는 모든 형태의 타입을 변수로 받을 수 있다. (자식 및 자손까지도)
// 다형성은 아직 느낌만 보자!! 나중에 차차 이해될 것!